//
// Copyright(C) 2024 Simon Howard
//
// You can redistribute and/or modify this program under the terms of
// the GNU General Public License version 2 as published by the Free
// Software Foundation, or any later version. This program is
// distributed WITHOUT ANY WARRANTY; without even the implied warranty
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
//
//
// Basic libpng wrapper functions for reading and writing PNG files
// through the VFILE interface.

#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include "common.h"
#include "fs/vfile.h"
#include "conv/error.h"
#include "conv/graphic.h"
#include "conv/vpng.h"

static jmp_buf libpng_abort_jump;

// TODO: Get palette from current WADs
const png_color doom_palette[256] = {
	{0x00, 0x00, 0x00}, {0x1f, 0x17, 0x0b},
	{0x17, 0x0f, 0x07}, {0x4b, 0x4b, 0x4b},
	{0xff, 0xff, 0xff}, {0x1b, 0x1b, 0x1b},
	{0x13, 0x13, 0x13}, {0x0b, 0x0b, 0x0b},
	{0x07, 0x07, 0x07}, {0x2f, 0x37, 0x1f},
	{0x23, 0x2b, 0x0f}, {0x17, 0x1f, 0x07},
	{0x0f, 0x17, 0x00}, {0x4f, 0x3b, 0x2b},
	{0x47, 0x33, 0x23}, {0x3f, 0x2b, 0x1b},
	{0xff, 0xb7, 0xb7}, {0xf7, 0xab, 0xab},
	{0xf3, 0xa3, 0xa3}, {0xeb, 0x97, 0x97},
	{0xe7, 0x8f, 0x8f}, {0xdf, 0x87, 0x87},
	{0xdb, 0x7b, 0x7b}, {0xd3, 0x73, 0x73},
	{0xcb, 0x6b, 0x6b}, {0xc7, 0x63, 0x63},
	{0xbf, 0x5b, 0x5b}, {0xbb, 0x57, 0x57},
	{0xb3, 0x4f, 0x4f}, {0xaf, 0x47, 0x47},
	{0xa7, 0x3f, 0x3f}, {0xa3, 0x3b, 0x3b},
	{0x9b, 0x33, 0x33}, {0x97, 0x2f, 0x2f},
	{0x8f, 0x2b, 0x2b}, {0x8b, 0x23, 0x23},
	{0x83, 0x1f, 0x1f}, {0x7f, 0x1b, 0x1b},
	{0x77, 0x17, 0x17}, {0x73, 0x13, 0x13},
	{0x6b, 0x0f, 0x0f}, {0x67, 0x0b, 0x0b},
	{0x5f, 0x07, 0x07}, {0x5b, 0x07, 0x07},
	{0x53, 0x07, 0x07}, {0x4f, 0x00, 0x00},
	{0x47, 0x00, 0x00}, {0x43, 0x00, 0x00},
	{0xff, 0xeb, 0xdf}, {0xff, 0xe3, 0xd3},
	{0xff, 0xdb, 0xc7}, {0xff, 0xd3, 0xbb},
	{0xff, 0xcf, 0xb3}, {0xff, 0xc7, 0xa7},
	{0xff, 0xbf, 0x9b}, {0xff, 0xbb, 0x93},
	{0xff, 0xb3, 0x83}, {0xf7, 0xab, 0x7b},
	{0xef, 0xa3, 0x73}, {0xe7, 0x9b, 0x6b},
	{0xdf, 0x93, 0x63}, {0xd7, 0x8b, 0x5b},
	{0xcf, 0x83, 0x53}, {0xcb, 0x7f, 0x4f},
	{0xbf, 0x7b, 0x4b}, {0xb3, 0x73, 0x47},
	{0xab, 0x6f, 0x43}, {0xa3, 0x6b, 0x3f},
	{0x9b, 0x63, 0x3b}, {0x8f, 0x5f, 0x37},
	{0x87, 0x57, 0x33}, {0x7f, 0x53, 0x2f},
	{0x77, 0x4f, 0x2b}, {0x6b, 0x47, 0x27},
	{0x5f, 0x43, 0x23}, {0x53, 0x3f, 0x1f},
	{0x4b, 0x37, 0x1b}, {0x3f, 0x2f, 0x17},
	{0x33, 0x2b, 0x13}, {0x2b, 0x23, 0x0f},
	{0xef, 0xef, 0xef}, {0xe7, 0xe7, 0xe7},
	{0xdf, 0xdf, 0xdf}, {0xdb, 0xdb, 0xdb},
	{0xd3, 0xd3, 0xd3}, {0xcb, 0xcb, 0xcb},
	{0xc7, 0xc7, 0xc7}, {0xbf, 0xbf, 0xbf},
	{0xb7, 0xb7, 0xb7}, {0xb3, 0xb3, 0xb3},
	{0xab, 0xab, 0xab}, {0xa7, 0xa7, 0xa7},
	{0x9f, 0x9f, 0x9f}, {0x97, 0x97, 0x97},
	{0x93, 0x93, 0x93}, {0x8b, 0x8b, 0x8b},
	{0x83, 0x83, 0x83}, {0x7f, 0x7f, 0x7f},
	{0x77, 0x77, 0x77}, {0x6f, 0x6f, 0x6f},
	{0x6b, 0x6b, 0x6b}, {0x63, 0x63, 0x63},
	{0x5b, 0x5b, 0x5b}, {0x57, 0x57, 0x57},
	{0x4f, 0x4f, 0x4f}, {0x47, 0x47, 0x47},
	{0x43, 0x43, 0x43}, {0x3b, 0x3b, 0x3b},
	{0x37, 0x37, 0x37}, {0x2f, 0x2f, 0x2f},
	{0x27, 0x27, 0x27}, {0x23, 0x23, 0x23},
	{0x77, 0xff, 0x6f}, {0x6f, 0xef, 0x67},
	{0x67, 0xdf, 0x5f}, {0x5f, 0xcf, 0x57},
	{0x5b, 0xbf, 0x4f}, {0x53, 0xaf, 0x47},
	{0x4b, 0x9f, 0x3f}, {0x43, 0x93, 0x37},
	{0x3f, 0x83, 0x2f}, {0x37, 0x73, 0x2b},
	{0x2f, 0x63, 0x23}, {0x27, 0x53, 0x1b},
	{0x1f, 0x43, 0x17}, {0x17, 0x33, 0x0f},
	{0x13, 0x23, 0x0b}, {0x0b, 0x17, 0x07},
	{0xbf, 0xa7, 0x8f}, {0xb7, 0x9f, 0x87},
	{0xaf, 0x97, 0x7f}, {0xa7, 0x8f, 0x77},
	{0x9f, 0x87, 0x6f}, {0x9b, 0x7f, 0x6b},
	{0x93, 0x7b, 0x63}, {0x8b, 0x73, 0x5b},
	{0x83, 0x6b, 0x57}, {0x7b, 0x63, 0x4f},
	{0x77, 0x5f, 0x4b}, {0x6f, 0x57, 0x43},
	{0x67, 0x53, 0x3f}, {0x5f, 0x4b, 0x37},
	{0x57, 0x43, 0x33}, {0x53, 0x3f, 0x2f},
	{0x9f, 0x83, 0x63}, {0x8f, 0x77, 0x53},
	{0x83, 0x6b, 0x4b}, {0x77, 0x5f, 0x3f},
	{0x67, 0x53, 0x33}, {0x5b, 0x47, 0x2b},
	{0x4f, 0x3b, 0x23}, {0x43, 0x33, 0x1b},
	{0x7b, 0x7f, 0x63}, {0x6f, 0x73, 0x57},
	{0x67, 0x6b, 0x4f}, {0x5b, 0x63, 0x47},
	{0x53, 0x57, 0x3b}, {0x47, 0x4f, 0x33},
	{0x3f, 0x47, 0x2b}, {0x37, 0x3f, 0x27},
	{0xff, 0xff, 0x73}, {0xeb, 0xdb, 0x57},
	{0xd7, 0xbb, 0x43}, {0xc3, 0x9b, 0x2f},
	{0xaf, 0x7b, 0x1f}, {0x9b, 0x5b, 0x13},
	{0x87, 0x43, 0x07}, {0x73, 0x2b, 0x00},
	{0xff, 0xff, 0xff}, {0xff, 0xdb, 0xdb},
	{0xff, 0xbb, 0xbb}, {0xff, 0x9b, 0x9b},
	{0xff, 0x7b, 0x7b}, {0xff, 0x5f, 0x5f},
	{0xff, 0x3f, 0x3f}, {0xff, 0x1f, 0x1f},
	{0xff, 0x00, 0x00}, {0xef, 0x00, 0x00},
	{0xe3, 0x00, 0x00}, {0xd7, 0x00, 0x00},
	{0xcb, 0x00, 0x00}, {0xbf, 0x00, 0x00},
	{0xb3, 0x00, 0x00}, {0xa7, 0x00, 0x00},
	{0x9b, 0x00, 0x00}, {0x8b, 0x00, 0x00},
	{0x7f, 0x00, 0x00}, {0x73, 0x00, 0x00},
	{0x67, 0x00, 0x00}, {0x5b, 0x00, 0x00},
	{0x4f, 0x00, 0x00}, {0x43, 0x00, 0x00},
	{0xe7, 0xe7, 0xff}, {0xc7, 0xc7, 0xff},
	{0xab, 0xab, 0xff}, {0x8f, 0x8f, 0xff},
	{0x73, 0x73, 0xff}, {0x53, 0x53, 0xff},
	{0x37, 0x37, 0xff}, {0x1b, 0x1b, 0xff},
	{0x00, 0x00, 0xff}, {0x00, 0x00, 0xe3},
	{0x00, 0x00, 0xcb}, {0x00, 0x00, 0xb3},
	{0x00, 0x00, 0x9b}, {0x00, 0x00, 0x83},
	{0x00, 0x00, 0x6b}, {0x00, 0x00, 0x53},
	{0xff, 0xff, 0xff}, {0xff, 0xeb, 0xdb},
	{0xff, 0xd7, 0xbb}, {0xff, 0xc7, 0x9b},
	{0xff, 0xb3, 0x7b}, {0xff, 0xa3, 0x5b},
	{0xff, 0x8f, 0x3b}, {0xff, 0x7f, 0x1b},
	{0xf3, 0x73, 0x17}, {0xeb, 0x6f, 0x0f},
	{0xdf, 0x67, 0x0f}, {0xd7, 0x5f, 0x0b},
	{0xcb, 0x57, 0x07}, {0xc3, 0x4f, 0x00},
	{0xb7, 0x47, 0x00}, {0xaf, 0x43, 0x00},
	{0xff, 0xff, 0xff}, {0xff, 0xff, 0xd7},
	{0xff, 0xff, 0xb3}, {0xff, 0xff, 0x8f},
	{0xff, 0xff, 0x6b}, {0xff, 0xff, 0x47},
	{0xff, 0xff, 0x23}, {0xff, 0xff, 0x00},
	{0xa7, 0x3f, 0x00}, {0x9f, 0x37, 0x00},
	{0x93, 0x2f, 0x00}, {0x87, 0x23, 0x00},
	{0x4f, 0x3b, 0x27}, {0x43, 0x2f, 0x1b},
	{0x37, 0x23, 0x13}, {0x2f, 0x1b, 0x0b},
	{0x00, 0x00, 0x53}, {0x00, 0x00, 0x47},
	{0x00, 0x00, 0x3b}, {0x00, 0x00, 0x2f},
	{0x00, 0x00, 0x23}, {0x00, 0x00, 0x17},
	{0x00, 0x00, 0x0b}, {0x00, 0x00, 0x00},
	{0xff, 0x9f, 0x43}, {0xff, 0xe7, 0x4b},
	{0xff, 0x7b, 0xff}, {0xff, 0x00, 0xff},
	{0xcf, 0x00, 0xcf}, {0x9f, 0x00, 0x9b},
	{0x6f, 0x00, 0x6b}, {0xa7, 0x6b, 0x6b},
};

static uint8_t FindColor(const png_color *pal, int r, int g, int b)
{
	int diff, best_diff = INT_MAX, i, best_idx = -1;

	for (i = 0; i < 256; i++) {
		diff = (r - pal[i].red) * (r - pal[i].red)
		     + (g - pal[i].green) * (g - pal[i].green)
		     + (b - pal[i].blue) * (b - pal[i].blue);
		if (diff == 0) {
			return i;
		}
		if (diff < best_diff) {
			best_idx = i;
			best_diff = diff;
		}
	}

	return best_idx;
}

uint8_t *V_PalettizeRGBABuffer(const png_color *palette, uint8_t *buf,
                               size_t rowstep, int width, int height)
{
	uint8_t *result, *pixel;
	int x, y;

	result = checked_calloc(width, height);

	for (y = 0; y < height; ++y) {
		for (x = 0; x < width; ++x) {
			pixel = &buf[y * rowstep + x * 4];
			result[y * width + x] = FindColor(
				palette, pixel[0], pixel[1], pixel[2]);
		}
	}

	return result;
}

static void ErrorCallback(png_structp p, png_const_charp s)
{
	ConversionError("%s", s);
	longjmp(libpng_abort_jump, 1);
}

static void WarningCallback(png_structp p, png_const_charp s)
{
	fprintf(stderr, "libpng warning: %s\n", s);
}

static void PngReadCallback(png_structp ppng, png_bytep buf, size_t len)
{
	VFILE *vf = png_get_io_ptr(ppng);
	int result;

	memset(buf, 0, len);
	result = vfread(buf, 1, len, vf);
	if (result == 0) {
		png_error(ppng, "end of file reached");
	} else if (result < 0) {
		png_error(ppng, "read error");
	}
}

static void PngWriteCallback(png_structp ppng, png_bytep buf, size_t len)
{
	VFILE *vf = png_get_io_ptr(ppng);
	vfwrite(buf, 1, len, vf);
}

static void PngFlushCallback(png_structp ppng)
{
	// no-op
}

void V_ClosePNG(struct png_context *ctx)
{
	if (ctx->write) {
		png_destroy_write_struct(&ctx->ppng, &ctx->pinfo);
	} else {
		png_destroy_read_struct(&ctx->ppng, &ctx->pinfo, NULL);
	}
}

bool V_OpenPNGRead(struct png_context *ctx, VFILE *input)
{
	ctx->ppng = NULL;
	ctx->pinfo = NULL;
	ctx->write = false;

	if (setjmp(libpng_abort_jump) != 0) {
		ConversionError("Error when parsing PNG file");
		V_ClosePNG(ctx);
		return NULL;
	}

	ctx->ppng = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL,
	                                   ErrorCallback, WarningCallback);
	if (ctx->ppng == NULL) {
		ConversionError("Failed to open PNG file");
		return false;
	}

	ctx->pinfo = png_create_info_struct(ctx->ppng);
	if (ctx->pinfo == NULL) {
		ConversionError("Failed to create PNG info struct");
		V_ClosePNG(ctx);
		return false;
	}

	png_set_read_fn(ctx->ppng, input, PngReadCallback);
	return true;
}

VFILE *V_OpenPNGWrite(struct png_context *ctx)
{
	VFILE *result;

	ctx->ppng = NULL;
	ctx->pinfo = NULL;
	ctx->write = true;

	if (setjmp(libpng_abort_jump) != 0) {
		ConversionError("Error when writing PNG file");
		V_ClosePNG(ctx);
		return NULL;
	}

	ctx->ppng = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL,
	                                    ErrorCallback, WarningCallback);
	if (!ctx->ppng) {
		ConversionError("Failed to create PNG write struct");
		return NULL;
	}

	ctx->pinfo = png_create_info_struct(ctx->ppng);
	if (!ctx->pinfo) {
		ConversionError("Failed to create PNG info struct");
		V_ClosePNG(ctx);
		return NULL;
	}

	result = vfopenmem(NULL, 0);
	png_set_write_fn(ctx->ppng, result, PngWriteCallback, PngFlushCallback);

	return result;
}
